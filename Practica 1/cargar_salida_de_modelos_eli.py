# -*- coding: utf-8 -*-
"""Cargar salida de modelos ELI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1It0LrDQikjykL2cLnxJU4OUvqV_VJ1hu
"""

import numpy as np
import os
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style("darkgrid")

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
#Mover a la carpeta dónde tenemos el modelo
# %cd /content/drive/MyDrive/CG/P1/Archivos
# %ls

"""INPUTS
dir_salida: str, direccion de la salida
Lx: float, tamano de la cuenca (direccion X)
Ly: float, tamano de la cuenca (direccion Y)
nx: int, numero de punto de grilla (direccion X)
ny: int, numero de punto de grilla (direccion Y)

OUTPUTS
psi_temp: Campos de función de corriente de todos los tiempos
vort_temp: Campos de vorticidada de todos los tiempos
psiF: Campo de función de corriente del tiempo final
vortF: Campo de vorticidad del tiempo final
QG_diag: Información temporal de función corriente, vorticidad y energía cinética en el punto central del dominio
QG_curlw: Campo del rotor del esfuerzo del viento utilizado en la simulación
X: Vector con los puntos del eje X dimensionalizado
Y: Vector con los puntos del eje Y dimensionalizado
dx: Distancia entre puntos del eje X
dy: Distancia entre puntos del eje y"""

def cargar(dir_salida,Lx,Ly,nx,ny):

    archivos = os.listdir(dir_salida) # nombre de los archivos en el directorio actual + \output

    tiempos = 0

    for name in archivos:
        if name[0:3] == 'psi':
            tiempos = tiempos+1

    # Creacion de las matriz para recibir los datos
    psi_temp = np.empty(shape=[ny+2,nx+2,tiempos])
    psi_temp[:] = np.nan
    vort_temp = np.empty(shape=[ny+2,nx+2,tiempos])
    vort_temp[:] = np.nan

    # Extraccion
    for name in archivos:
        if name[0:3] == 'psi':
            k1 = name[3]+name[4]
            psi_temp[:,:,int(k1)-1] = np.loadtxt(dir_salida+name) #fromfile(name)
        if name[0:3] =='vor':
            k2 = name[3]+name[4]
            vort_temp[:,:,int(k2)-1] = np.loadtxt(dir_salida+name) #fromfile(name)
        if name[0:7] == 'QG_diag':
            QG_diag = np.loadtxt(dir_salida+name) #fromfile(name)
            # En el punto central del dominio
            # (Tiempo, Funcion Corriente,Vorticidad, EnCin)
        if name[0:7] == 'QG_wind':
            QG_curlw = np.loadtxt(dir_salida+name) #fromfile(name)

    # Recorte de los datos
    a1 = 1; a2 = np.size(vort_temp,0)-1
    b1 = 1; b2 = np.size(vort_temp,1)-1

    psi_temp = psi_temp[a1:a2,b1:b2,:]
    psiF = psi_temp[:,:,np.size(psi_temp,2)-1]

    vort_temp = vort_temp[a1:a2,b1:b2,:]
    vortF = vort_temp[:,:,np.size(vort_temp,2)-1]

    X = np.linspace(0,Lx,num=nx)
    Y = np.linspace(0,Ly,num=ny)

    dx = Lx/(nx-1)
    dy = Ly/(ny-1)

    return ("psi", psi_temp, "vort", vort_temp, "psi F", psiF, "vort F", vortF, "QG_diag", QG_diag, "QG_curlw" , QG_curlw, "X", X, "Y", Y, "dx", dx, "dy", dy)

salidaS1 = '/content/drive/MyDrive/CG/P1/Archivos/out_tmpS1/'
salidaS2 = '/content/drive/MyDrive/CG/P1/Archivos/out_tmpS2/'
salidaM1 = '/content/drive/MyDrive/CG/P1/Archivos/out_tmpM1/'
salidaM2 = '/content/drive/MyDrive/CG/P1/Archivos/out_tmpM2/'

S1= cargar(salidaS1, 4000, 2000, 200, 100)
S2= cargar(salidaS2, 4000, 2000, 200, 100)
M1= cargar(salidaM1, 4000, 2000, 200, 100)
M2= cargar(salidaM2, 4000, 2000, 200, 100)

"""QG_diag: Información temporal de función corriente, vorticidad y energía cinética en el punto central del dominio

### Estabilización del modelo
"""

"""
Número de iteraciones para alcanzar el estado estacionario
Leandro Díaz, Daniela Risaro
2022

"""
def calc_tiempo_estabilizacion(tke):
    ECfinal=tke[-1]
    error_ECfinal=ECfinal/100
    i=1
    while i<len(tke):
        if abs(tke[-i]-ECfinal)<error_ECfinal:
            i=i+1
        else:
            TiempoEst=len(tke)-i
            break
    return TiempoEst

QG_diagS1=S1[9][:,3] #elijo qg_diag y la última columna que es la energía cinética total
QG_diagS2=S2[9][:,3]
QG_diagM1=M1[9][:,3]
QG_diagM2=M2[9][:,3]
print("Tiempo estabilizado S1: ",calc_tiempo_estabilizacion(QG_diagS1))
print("Tiempo estabilizado S2: ",calc_tiempo_estabilizacion(QG_diagS2))
print("Tiempo estabilizado M1: ",calc_tiempo_estabilizacion(QG_diagM1))
print("Tiempo estabilizado M2: ",calc_tiempo_estabilizacion(QG_diagM2))

# Datos de energía cinética
tiempoS1 = np.arange(0, len(QG_diagS1))
tiempoS2 = np.arange(0, len(QG_diagS2))
tiempoM1 = np.arange(0, len(QG_diagM1))
tiempoM2 = np.arange(0, len(QG_diagM2))

# Gráfico
plt.figure(figsize=(10, 6))
plt.plot(tiempoS1, QG_diagS1, color= 'darkcyan', label='S1')
plt.plot(tiempoS2, QG_diagS2, color= 'darkmagenta',label='S2')
plt.plot(tiempoM1, QG_diagM1, label='M1')
plt.plot(tiempoM2, QG_diagM2, label='M2')

plt.xlabel('Pasos temporales')
plt.ylabel('Energía Cinética')
plt.title('Energía Cinética en función del Tiempo')
plt.legend(loc= 'lower right')
plt.grid(True)
plt.show()

"""# Ejercicio 2"""

psiadim1=S1[5]
psiadim2=S2[5]
psiadim3=M1[5]
psiadim4=M2[5]
vortadim1=S1[7]
vortadim2=S2[7]
vortadim3=M1[7]
vortadim4=M2[7]

import math

# Escalas tipicas
tau = 0.25          #Tension del viento [N/m^2]
L = 4000000         # Longitud de la cuenca [m]
D = 2500            # Profundidad [m]
beta = 2e-11        # Coeficiente de Coriolis [1/(s*m)]
rho = 1025          # Densidad [kg/m^3]
K= 1.16e-7
Ef = K/(beta*L)

# Parametros para la dimensionalizacion
U = (2*math.pi*tau)/(rho*D*beta*L)                              # Velocidad
Ro = (2*math.pi*tau)/(rho*D*(math.pow(beta,2)*(math.pow(L,3)))) # Numero de Rossby

# Energia cinetica
tkeS1 =  QG_diagS1 # la tercera columna tiene la Energia cinetica total
tkeS2 =  QG_diagS2
tkeM1 =  QG_diagM1
tkeM2 =  QG_diagM2

# Dimensionalizacion de las variables
psidim1 = psiadim1*U*L
psidim2 = psiadim2*U*L
psidim3 = psiadim3*U*L
psidim4 = psiadim4*U*L
vortdim1 = vortadim1*U/L
vortdim2 = vortadim2*U/L
vortdim3 = vortadim3*U/L
vortdim4 = vortadim4*U/L

# Calcular el rango común de valores
all_data = np.concatenate([psidim1.ravel(), psidim2.ravel(), psidim3.ravel(), psidim4.ravel()])
vmin, vmax = all_data.min(), all_data.max()

# Crear una figura y una cuadrícula de subplots
fig, axs = plt.subplots(2, 2, figsize=(12, 10))
CS4 = axs[1, 1].contourf(M2[13], M2[15], psidim4, cmap='viridis', vmin=vmin, vmax=vmax)

# Gráfico 1
CS1 = axs[0, 0].contourf(S1[13], S1[15], psidim1, cmap='viridis', vmin=vmin, vmax=vmax)
fig.colorbar(CS4, ax=axs[0, 0])
axs[0, 0].set_xlabel('Distancia zonal (km)')
axs[0, 0].set_ylabel('Distancia meridional (km)')
axs[0, 0].set_title('Función Corriente de S1')

# Gráfico 2
CS2 = axs[0, 1].contourf(S2[13], S2[15], psidim2, cmap='viridis', vmin=vmin, vmax=vmax)
fig.colorbar(CS4, ax=axs[0, 1])
axs[0, 1].set_xlabel('Distancia zonal (km)')
axs[0, 1].set_ylabel('Distancia meridional (km)')
axs[0, 1].set_title('Función Corriente de S2')

# Gráfico 3
CS3 = axs[1, 0].contourf(M1[13], M1[15], psidim3, cmap='viridis', vmin=vmin, vmax=vmax)
fig.colorbar(CS4, ax=axs[1, 0])
axs[1, 0].set_xlabel('Distancia zonal (km)')
axs[1, 0].set_ylabel('Distancia meridional (km)')
axs[1, 0].set_title('Función Corriente de M1')

# Gráfico 4
CS4 = axs[1, 1].contourf(M2[13], M2[15], psidim4, cmap='viridis', vmin=vmin, vmax=vmax)
fig.colorbar(CS4, ax=axs[1, 1])
axs[1, 1].set_xlabel('Distancia zonal (km)')
axs[1, 1].set_ylabel('Distancia meridional (km)')
axs[1, 1].set_title('Función Corriente de M2')

# Ajustar el diseño
plt.tight_layout()

# Mostrar la figura
plt.show()

import matplotlib.pyplot as plt
plt.rcdefaults()

# Crear una figura y una cuadrícula de subplots
fig, axs = plt.subplots(2, 2, figsize=(12, 10))
plt.title('Campo de vorticidad para Stommel (izq) y Munk (der)', loc='center')

# Gráfico 1: Vorticidad de S1
CS1 = axs[0, 0].contourf(S1[13], S1[15], vortdim1, cmap='summer')
cbar1 = fig.colorbar(CS1, ax=axs[0, 0])
axs[0, 0].set_xlim(0,400)
axs[0, 0].set_xlabel('Distancia zonal (km)')
axs[0, 0].set_ylabel('Distancia meridional (km)')
axs[0, 0].set_title('Vorticidad de S1')

# Gráfico 2: Vorticidad de S2 (suponiendo que tienes datos de S2)
CS2 = axs[0, 1].contourf(S2[13], S2[15], vortdim2, cmap='summer')
cbar2 = fig.colorbar(CS1, ax=axs[0, 1])
axs[1, 0].set_xlim(0,400)
axs[1, 0].set_xlabel('Distancia zonal (km)')
axs[1, 0].set_ylabel('Distancia meridional (km)')
axs[1, 0].set_title('Vorticidad de S2')

# Gráfico 3: Vorticidad de M1 (suponiendo que tienes datos de M1)
CS3 = axs[1, 0].contourf(M1[13], M1[15], vortdim3, cmap='summer')
cbar3 = fig.colorbar(CS1, ax=axs[1, 0])
axs[0, 1].set_xlim(0,400)
axs[0, 1].set_xlabel('Distancia zonal (km)')
axs[0, 1].set_ylabel('Distancia meridional (km)')
axs[0, 1].set_title('Vorticidad de M1')

# Gráfico 4: Vorticidad de M2 (suponiendo que tienes datos de M2)
CS4 = axs[1, 1].contourf(M2[13], M2[15], vortdim4, cmap='summer')
cbar4 = fig.colorbar(CS1, ax=axs[1, 1])
axs[1, 1].set_xlim(0,400)
axs[1, 1].set_xlabel('Distancia zonal (km)')
axs[1, 1].set_ylabel('Distancia meridional (km)')
axs[1, 1].set_title('Vorticidad de M2')

# Ajustar el diseño para que los subplots no se solapen
plt.tight_layout()

# Mostrar la figura
plt.show()

# Transporte meridional promediado en la vertical (derivada zonal de la función corriente multiplicada por la profundidad)
trans_mer1 = np.diff(psiadim1, n=1, axis=1)*D
trans_mer2 = np.diff(psiadim2, n=1, axis=1)*D
trans_mer3 = np.diff(psiadim3, n=1, axis=1)*D
trans_mer4 = np.diff(psiadim4, n=1, axis=1)*D

import matplotlib.pyplot as plt
import numpy as np

# Crear una figura y una cuadrícula de subplots
fig, axs = plt.subplots(2, 2, figsize=(12, 10))

# Definir los límites de la barra de colores
vmin, vmax = -30000, 30000

# Gráfico 1
CS1 = axs[0, 0].contourf(S1[13][0:199], S1[15][0:199], trans_mer1, cmap='coolwarm', vmin=vmin, vmax=vmax)
axs[0,0].set_xlim(0,150)
axs[0, 0].set_xlabel('Distancia zonal (km)')
axs[0, 0].set_ylabel('Distancia meridional (km)')
axs[0, 0].set_title('Transporte meridional de S1')

# Gráfico 2
CS2 = axs[0, 1].contourf(S1[13][0:199], S1[15][0:199], trans_mer2, cmap='coolwarm', vmin=vmin, vmax=vmax)
axs[0,1].set_xlim(0,150)
axs[0, 1].set_xlabel('Distancia zonal (km)')
axs[0, 1].set_ylabel('Distancia meridional (km)')
axs[0, 1].set_title('Transporte meridional de S2')

# Gráfico 3
CS3 = axs[1, 0].contourf(S1[13][0:199], S1[15][0:199], trans_mer3, cmap='coolwarm', vmin=vmin, vmax=vmax)
axs[1,0].set_xlim(0,150)
axs[1, 0].set_xlabel('Distancia zonal (km)')
axs[1, 0].set_ylabel('Distancia meridional (km)')
axs[1, 0].set_title('Transporte meridional de M1')

# Gráfico 4
CS4 = axs[1, 1].contourf(S1[13][0:199], S1[15][0:199], trans_mer4, cmap='coolwarm', vmin=vmin, vmax=vmax)
axs[1,1].set_xlim(0,150)
axs[1, 1].set_xlabel('Distancia zonal (km)')
axs[1, 1].set_ylabel('Distancia meridional (km)')
axs[1, 1].set_title('Transporte meridional de M2')

# Crear un espacio para la barra de colores compartida
cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])  # [left, bottom, width, height]

# Añadir la barra de colores compartida
fig.colorbar(CS4, cax=cbar_ax, extend='both')

# Ajustar el diseño
plt.tight_layout(rect=[0, 0, 0.9, 1])  # Ajustar para que los subplots no se solapen con la barra de colores

# Mostrar la figura
plt.show()

trans_mer1 = np.diff(psiadim1, n=1, axis=1)*D
trans_mer2 = np.diff(psiadim2, n=1, axis=1)*D
trans_mer3 = np.diff(psiadim3, n=1, axis=1)*D
trans_mer4 = np.diff(psiadim4, n=1, axis=1)*D

trans_mer1[49]
trans_mer2[49]
trans_mer3[49]
trans_mer4[49]

sns.set_style("darkgrid")

# Gráfico
plt.figure(figsize=(10, 6))
plt.plot(S1[13][0:199], trans_mer1[49], color= 'darkcyan', ms=3, label='S1')
plt.plot(S1[13][0:199], trans_mer2[49], color= 'darkmagenta',label='S2')
plt.plot(S1[13][0:199], trans_mer3[49], color= 'orange', label='M1')
plt.plot(S1[13][0:199], trans_mer4[49], label='M2')

plt.xlabel('Distancia zonal [km]')
plt.ylabel('Transporte[Sv]')
plt.title('Corte zonal del transporte meridional de la mitad de la cuenca')
#plt.ylim(-25,500)
plt.xlim(-10,600)
plt.legend(loc= 'lower right')
plt.grid(True)
plt.show()
 #cerca del cco se tiene un transporte negativo, en el oeste se ve la cco, intensificación del flujo en esa zona
 #transporte hacia el Sur

sns.set_style("darkgrid")
vortdim1 = vortadim1*U/L
vortdim2 = vortadim2*U/L
vortdim3 = vortadim3*U/L
vortdim4 = vortadim4*U/L

# Gráfico
plt.figure(figsize=(10, 6))
plt.plot(S1[13][0:50], vortdim1[49, 0:50], color= 'darkcyan', ms=3, label='S1')
plt.plot(S1[13][0:50], vortdim2[49, 0:50], color= 'darkmagenta',label='S2')
plt.plot(S1[13][0:50], vortdim3[49, 0:50], color= 'orange', label='M1')
plt.plot(S1[13][0:50], vortdim4[49, 0:50], label='M2')

plt.xlabel('Distancia zonal [km]')
plt.ylabel('Vorticidad relativa[s-1')
plt.title('Corte zonal de vorticidad relativa de la mitad de la cuenca')
#plt.ylim(-25,500)
#plt.xlim(-10,600)
plt.legend(loc= 'upper right')
plt.grid(True)
plt.show()

def Calc_TrasMer_CBO_LatCent(X,psiF,U,L,D):

    """
    Calculo de Extensión de la Corriente de Borde Oeste en la latitud central,
    Calculo de Transporte total meridional de la Corriente de Borde Oeste en la latitud central
    Calculo de transporte total meridional en la latitud central

    INPUTS

    OUTPUTS
    """

    TrasMer=np.diff(psiF,n=1,axis=1)*U*L*D
    TrasMer_LatCent=TrasMer[int(np.size(TrasMer,0)/2),:]
    X_mod=X[0:-1]-(X[1]-X[0])/2

    a=TrasMer_LatCent[0]/abs(TrasMer_LatCent[0])
    i=1
    m=0
    while i<len(TrasMer_LatCent):
        b=TrasMer_LatCent[i]/abs(TrasMer_LatCent[i])
        if b==a:
            i=i+1
        else:
            m=i
            break
    Limite_CBO_LatCent=X_mod[m]+(X[1]-X[0])/2
    TrasMer_CBO_LatCent=sum(TrasMer_LatCent[0:m+1])/1000000
    TrasMer_total_LatCent=sum(TrasMer_LatCent)/1000000

    return ('Limite_CBO_LatCent- Ancho', Limite_CBO_LatCent, 'TrasMer_CBO_LatCent', TrasMer_CBO_LatCent, 'TrasMer_total_LatCent', TrasMer_total_LatCent)

"""Ejercicio 4"""

psiadim1=S1[5]
psiadim2=S2[5]
psiadim3=M1[5]
psiadim4=M2[5]
X= S1[13]

print(Calc_TrasMer_CBO_LatCent(X,psiadim1,U,L,D))
print(Calc_TrasMer_CBO_LatCent(X,psiadim2,U,L,D))
print(Calc_TrasMer_CBO_LatCent(X,psiadim3,U,L,D))
print(Calc_TrasMer_CBO_LatCent(X,psiadim4,U,L,D))

"""Ejercicio 5"""

def Calc_del2(array_2D, ds):

    #Cargamos las librerias necesarias
    import numpy as np
    del2 = np.zeros(array_2D.shape, float)
    del2[1:-1, 1:-1] = (array_2D[1:-1,2:] + array_2D[1:-1,:-2] + array_2D[2:,1:-1] + array_2D[:-2,1:-1] - 4.*array_2D[1:-1,1:-1])/(ds*ds)
    return del2

QG_curlwS1 = S1[11]
QG_curlwM1 = M1[11]
nx= 200
ny= 100


# Escalas tipicas
tau = 0.25          #Tension del viento [N/m^2]
L = 4000000         # Longitud de la cuenca [m]
D = 2500            # Profundidad [m]
beta = 2e-11        # Coeficiente de Coriolis [1/(s*m)]
rho = 1025          # Densidad [kg/m^3]
A = 500
K = 1.16e-7
Ev1 = A/(beta*L**2)
Ef = K/(beta*L)

# Parametros para la dimensionalizacion
U = (2*math.pi*tau)/(rho*D*beta*L)                              # Velocidad
Ro = (2*math.pi*tau)/(rho*D*(math.pow(beta,2)*(math.pow(L,3)))) # Numero de Rossby

# Terminos ecuacion de stommel
ds = 0.1
ter1 = np.diff(psiadim1, n=1, axis=1)
ter1_LatCent = np.squeeze(ter1[int(np.size(ter1,0)/2),:])/ds

ter2 = -QG_curlwS1[int(np.size(ter1,0)/2),1:(nx+1)]
ter3 = Ef*vortadim1[int(np.size(ter1,0)/2),:]

# Terminos ecuacion Munk
term1 = np.diff(psiadim3,n=1,axis=1)[int(np.size(psiadim3,0)/2),:]/ds
term2 = -QG_curlwM1[int(np.size(QG_curlwM1,0)/2),1:-1]
term3 = -Ev1*Calc_del2(vortadim3,ds)[int(np.size(vortadim3,0)/2),:]

"""Ejercicio 6"""

